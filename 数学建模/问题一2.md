# 纺织品克重高分辨率重建与局部轻质缺陷检测 - 问题一实现与分析

基于您提供的数据和执行结果，我将进行问题一的详细分析和实现。

## 1. 问题一：建立数学关系模型

我们需要建立1mm观测数据真实克重分布与6mm观测数据之间的数学关系模型，包括探测窗口函数的建模和噪声影响的考虑。

## 2. Python代码实现

以下是完整的Python代码实现，包括数据读取、窗口函数定义、卷积模型实现以及误差评估：

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import signal

# 读取数据
measured_6mm = pd.read_csv('measured_gsm_6mm.csv')
measured_1mm = pd.read_csv('measured_gsm_1mm.csv')

# 获取数据数组
gsm_6mm = measured_6mm['MeasuredGSM'].values
gsm_1mm = measured_1mm['MeasuredGSM'].values

# 输出基本信息
print(f"6mm数据点数: {len(gsm_6mm)}")
print(f"1mm数据点数: {len(gsm_1mm)}")
print(f"6mm数据均值: {np.mean(gsm_6mm):.2f}, 标准差: {np.std(gsm_6mm):.2f}")
print(f"1mm数据均值: {np.mean(gsm_1mm):.2f}, 标准差: {np.std(gsm_1mm):.2f}")

# 创建坐标轴（单位：mm）
x_6mm = np.arange(len(gsm_6mm)) * 0.1  # 0.1mm步长
x_1mm = np.arange(len(gsm_1mm)) * 0.1  # 0.1mm步长

# 定义窗口函数
def rect_window(x, width=6):
    """矩形窗口函数"""
    half_width = width / 2
    return np.where(np.abs(x) <= half_width, 1/width, 0)

def gaussian_window(x, sigma=1.5):
    """高斯窗口函数"""
    return np.exp(-0.5 * (x/sigma)**2) / (sigma * np.sqrt(2*np.pi))

def triangle_window(x, width=6):
    """三角窗口函数"""
    half_width = width / 2
    y = np.zeros_like(x, dtype=float)
    mask = np.abs(x) <= half_width
    y[mask] = (half_width - np.abs(x[mask])) / (half_width**2)
    return y

# 实现卷积模型
def convolve_with_window(true_gsm, window_func, window_width=6, step=0.1):
    """使用给定窗口函数对真实克重数据进行卷积，模拟测量过程"""
    # 创建离散窗口函数
    half_points = int(window_width / (2 * step))
    x_window = np.linspace(-half_points*step, half_points*step, 2*half_points+1)
    window = window_func(x_window)
    window = window / np.sum(window)  # 确保窗口函数归一化
    
    # 进行卷积
    measured = np.convolve(true_gsm, window, mode='same')
    return measured

# 添加噪声
def add_noise(signal, noise_level=0.02):
    """添加指定比例的高斯噪声"""
    mean_signal = np.mean(signal)
    noise = np.random.normal(0, noise_level * mean_signal, len(signal))
    return signal + noise

# 使用1mm数据和不同窗口函数生成模拟的6mm测量数据
np.random.seed(42)  # 设置随机种子以确保结果可重复
simulated_6mm_rect = convolve_with_window(gsm_1mm, rect_window)
simulated_6mm_gauss = convolve_with_window(gsm_1mm, gaussian_window)
simulated_6mm_tri = convolve_with_window(gsm_1mm, triangle_window)

# 添加2%噪声
simulated_6mm_rect_noisy = add_noise(simulated_6mm_rect)
simulated_6mm_gauss_noisy = add_noise(simulated_6mm_gauss)
simulated_6mm_tri_noisy = add_noise(simulated_6mm_tri)

# 计算误差指标
def calculate_errors(actual, simulated):
    """计算模拟数据与实际数据之间的误差指标"""
    min_len = min(len(actual), len(simulated))
    actual = actual[:min_len]
    simulated = simulated[:min_len]
    
    mse = np.mean((actual - simulated) ** 2)
    rmse = np.sqrt(mse)
    mae = np.mean(np.abs(actual - simulated))
    
    return {'MSE': mse, 'RMSE': rmse, 'MAE': mae}

# 计算三种窗口函数模拟结果的误差
error_rect = calculate_errors(gsm_6mm, simulated_6mm_rect_noisy)
error_gauss = calculate_errors(gsm_6mm, simulated_6mm_gauss_noisy)
error_tri = calculate_errors(gsm_6mm, simulated_6mm_tri_noisy)

# 输出误差结果
print("\n不同窗口函数模拟结果的误差:")
print(f"矩形窗口: {error_rect}")
print(f"高斯窗口: {error_gauss}")
print(f"三角窗口: {error_tri}")

# 可视化窗口函数
plt.figure(figsize=(10, 5))
x_window = np.linspace(-5, 5, 1000)
plt.plot(x_window, rect_window(x_window), label='矩形窗口')
plt.plot(x_window, gaussian_window(x_window), label='高斯窗口')
plt.plot(x_window, triangle_window(x_window), label='三角窗口')
plt.xlabel('距离中心点的位置 (mm)')
plt.ylabel('权重')
plt.title('不同窗口函数的权重分布')
plt.legend()
plt.grid(True)
plt.tight_layout()

# 创建可视化比较原始6mm数据与模拟6mm数据
plt.figure(figsize=(15, 10))

# 选择一段有代表性的数据（前600个点，对应60mm）进行可视化
sample_range = 600
x_sample = x_6mm[:sample_range]

plt.subplot(3, 1, 1)
plt.plot(x_sample, gsm_6mm[:sample_range], 'b-', label='实际6mm测量')
plt.plot(x_sample, simulated_6mm_rect_noisy[:sample_range], 'r--', label='矩形窗口模拟')
plt.title('矩形窗口模拟与实际6mm测量数据比较')
plt.xlabel('位置 (mm)')
plt.ylabel('克重 (gsm)')
plt.legend()
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(x_sample, gsm_6mm[:sample_range], 'b-', label='实际6mm测量')
plt.plot(x_sample, simulated_6mm_gauss_noisy[:sample_range], 'r--', label='高斯窗口模拟')
plt.title('高斯窗口模拟与实际6mm测量数据比较')
plt.xlabel('位置 (mm)')
plt.ylabel('克重 (gsm)')
plt.legend()
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(x_sample, gsm_6mm[:sample_range], 'b-', label='实际6mm测量')
plt.plot(x_sample, simulated_6mm_tri_noisy[:sample_range], 'r--', label='三角窗口模拟')
plt.title('三角窗口模拟与实际6mm测量数据比较')
plt.xlabel('位置 (mm)')
plt.ylabel('克重 (gsm)')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()
```

## 3. 数据分析结果

根据您提供的执行结果，我们获得以下关键信息：

1. **基本数据统计**：
   - 6mm数据点数: 6000
   - 1mm数据点数: 6000
   - 6mm数据均值: 99.56，标准差: 3.61
   - 1mm数据均值: 99.75，标准差: 2.01

2. **不同窗口函数模拟结果的误差**：
   - 矩形窗口: MSE = 8.07, RMSE = 2.84, MAE = 2.27
   - 高斯窗口: MSE = 8.27, RMSE = 2.88, MAE = 2.28
   - 三角窗口: MSE = 8.97, RMSE = 3.00, MAE = 2.37

## 4. 最终数学模型确定

根据误差分析，矩形窗口在所有误差指标上都略优于其他窗口函数，因此我们选择**矩形窗口函数**作为探测窗口的最佳模型。

### 4.1 矩形窗口函数定义

$$h_{rect}(x) = \begin{cases}
\frac{1}{6}, & \text{if } |x| \leq 3 \text{ mm} \\
0, & \text{otherwise}
\end{cases}$$

这表明探测器对窗口内的所有点赋予相同权重，这符合许多工业传感器的工作特性。

### 4.2 最终数学关系模型

根据以上分析，6mm观测数据与1mm真实克重分布之间的数学关系为：

$$m(x_i) = \sum_{j=-30}^{30} w(x_i + j \cdot 0.1) \cdot h_{rect}(j \cdot 0.1) + n(x_i)$$

其中：
- $m(x_i)$ 是位置 $x_i$ 处的6mm窗口测量值
- $w(x)$ 是真实克重分布函数（1mm分辨率）
- $h_{rect}(x)$ 是矩形窗口函数
- $n(x_i)$ 是加性噪声，服从正态分布 $\mathcal{N}(0, (\alpha \cdot \bar{w})^2)$，其中 $\alpha = 0.02$（2%噪声水平）

简化后，矩形窗口的数学关系可以表示为：

$$m(x_i) = \frac{1}{60} \sum_{j=-30}^{30} w(x_i + j \cdot 0.1) + n(x_i)$$

这意味着每个6mm测量值实际上是60个相邻0.1mm步长点的平均值加上噪声。

## 5. 缺陷检测困难性分析

根据建立的数学模型，我们可以解释为什么宽度小于6mm的局部轻质缺陷在6mm窗口测量中难以检测：

1. **信息平均化效应**：6mm窗口对范围内的所有点取平均，导致局部缺陷信号被"稀释"。例如，一个宽度为3mm、深度为10%的缺陷，在6mm窗口中最多只会表现为约5%的克重下降。

2. **测量噪声掩盖**：2%的测量噪声进一步降低了检测小缺陷的可能性。当缺陷信号被平均后降至与噪声水平相当时，就很难被可靠检测。

3. **高度重叠的采样**：虽然0.1mm的步长使得相邻测量高度重叠，但每个测量点仍然包含了相同的6mm窗口信息，没有提供更高分辨率的详细信息。

## 6. 结论

我们成功建立了1mm观测数据真实克重分布与6mm观测数据之间的数学关系模型：

1. **数学模型**：6mm窗口测量值可以被建模为真实克重分布在矩形窗口下的卷积加2%高斯噪声。

2. **窗口函数选择**：基于误差分析，矩形窗口函数最能代表实际测量系统的特性。

3. **缺陷检测挑战**：模型解释了为什么宽度小于6mm的局部轻质缺陷难以被直接检测到——它们在6mm窗口下的信号被严重"稀释"。

这个数学模型为问题二（高分辨率克重分布的反演）提供了必要的理论基础。通过理解测量数据的生成机制，我们可以设计适当的反卷积或去卷积算法，从6mm窗口测量数据中恢复更高分辨率的克重分布。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI0OTA3MjgxMl19
-->